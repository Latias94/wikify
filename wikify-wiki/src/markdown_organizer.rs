//! Simplified markdown file organization and export
//!
//! This module handles the final organization of markdown content that has been
//! directly generated by LLMs. It focuses on file management, metadata, and export.

use crate::types::{ImportanceLevel, WikiPage, WikiStructure};
use std::collections::HashMap;
use tracing::{debug, info};

/// Configuration options for markdown file organization
#[derive(Debug, Clone)]
pub struct MarkdownOptions {
    /// Include navigation file
    pub include_navigation: bool,
    /// Include metadata frontmatter
    pub include_frontmatter: bool,
    /// Use emoji in navigation
    pub use_emoji: bool,
}

impl Default for MarkdownOptions {
    fn default() -> Self {
        Self {
            include_navigation: true,
            include_frontmatter: true,
            use_emoji: true,
        }
    }
}

/// Simplified markdown file organizer for wiki content
pub struct MarkdownOrganizer {
    /// Generation options
    options: MarkdownOptions,
}

impl MarkdownOrganizer {
    /// Create a new markdown organizer
    pub fn new(options: MarkdownOptions) -> Self {
        Self { options }
    }

    /// Organize wiki content into markdown files
    pub fn organize_wiki_files(&self, wiki: &WikiStructure) -> HashMap<String, String> {
        info!("Organizing markdown files for {} pages", wiki.pages.len());

        let mut markdown_files = HashMap::new();

        // Generate index page
        let index_content = self.generate_index_page(wiki);
        markdown_files.insert("README.md".to_string(), index_content);

        // Organize individual pages (content is already markdown)
        for page in &wiki.pages {
            let content = self.finalize_page_content(page);
            let filename = format!("{}.md", page.id.replace(' ', "-").to_lowercase());
            markdown_files.insert(filename, content);
        }

        // Generate navigation file if enabled
        if self.options.include_navigation {
            let nav_content = self.generate_navigation_file(wiki);
            markdown_files.insert("NAVIGATION.md".to_string(), nav_content);
        }

        info!("Organized {} markdown files", markdown_files.len());
        markdown_files
    }

    /// Finalize page content (content is already markdown from LLM)
    fn finalize_page_content(&self, page: &WikiPage) -> String {
        debug!("Finalizing content for page: {}", page.title);

        let mut content = String::new();

        // Add frontmatter if enabled
        if self.options.include_frontmatter {
            content.push_str(&self.generate_frontmatter(page));
        }

        // The page content is already complete markdown from direct generation
        content.push_str(&page.content);

        // Add footer navigation if there are related pages
        if !page.related_pages.is_empty() {
            content.push_str(&self.generate_page_footer(page));
        }

        content
    }

    /// Generate frontmatter for a page
    fn generate_frontmatter(&self, page: &WikiPage) -> String {
        format!(
            "---\ntitle: {}\ndescription: {}\nimportance: {}\ntags: [{}]\nreading_time: {} min\ngenerated_at: {}\n---\n\n",
            page.title,
            page.description,
            page.importance.as_str(),
            page.tags.join(", "),
            page.reading_time,
            page.generated_at.format("%Y-%m-%d")
        )
    }

    /// Generate footer navigation for a page
    fn generate_page_footer(&self, page: &WikiPage) -> String {
        let mut footer = String::from("\n\n---\n\n## ğŸ”— Related Pages\n\n");

        for related_page in &page.related_pages {
            let filename = format!("{}.md", related_page.replace(' ', "-").to_lowercase());
            footer.push_str(&format!("- [{}](./{})\n", related_page, filename));
        }

        footer
    }

    /// Generate index page for the wiki
    fn generate_index_page(&self, wiki: &WikiStructure) -> String {
        let mut content = String::new();

        // Hero section
        content.push_str(&format!("# {}\n\n", wiki.title));
        content.push_str(&format!("{}\n\n", wiki.description));

        // Quick stats
        let critical_count = wiki
            .pages
            .iter()
            .filter(|p| p.importance == ImportanceLevel::Critical)
            .count();
        let high_count = wiki
            .pages
            .iter()
            .filter(|p| p.importance == ImportanceLevel::High)
            .count();
        let total_reading_time = wiki.total_reading_time();

        if self.options.use_emoji {
            content.push_str("## ğŸ“Š Quick Stats\n\n");
            content.push_str(&format!("- ğŸ“š **{}** total pages\n", wiki.pages.len()));
            content.push_str(&format!("- ğŸ¯ **{}** critical pages\n", critical_count));
            content.push_str(&format!("- ğŸ“– **{}** high priority pages\n", high_count));
            content.push_str(&format!(
                "- â±ï¸ **~{} minutes** total reading time\n\n",
                total_reading_time
            ));
        } else {
            content.push_str("## Quick Stats\n\n");
            content.push_str(&format!("- **{}** total pages\n", wiki.pages.len()));
            content.push_str(&format!("- **{}** critical pages\n", critical_count));
            content.push_str(&format!("- **{}** high priority pages\n", high_count));
            content.push_str(&format!(
                "- **~{} minutes** total reading time\n\n",
                total_reading_time
            ));
        }

        // Page listing by importance
        self.add_pages_by_importance(&mut content, wiki);

        content
    }

    /// Add pages organized by importance to content
    fn add_pages_by_importance(&self, content: &mut String, wiki: &WikiStructure) {
        // Group pages by importance
        let mut critical_pages = Vec::new();
        let mut high_pages = Vec::new();
        let mut medium_pages = Vec::new();
        let mut low_pages = Vec::new();

        for page in &wiki.pages {
            match page.importance {
                ImportanceLevel::Critical => critical_pages.push(page),
                ImportanceLevel::High => high_pages.push(page),
                ImportanceLevel::Medium => medium_pages.push(page),
                ImportanceLevel::Low => low_pages.push(page),
            }
        }

        // Add sections
        if !critical_pages.is_empty() {
            content.push_str("## ğŸ”¥ Essential Reading\n\n");
            for page in critical_pages {
                let filename = format!("{}.md", page.id.replace(' ', "-").to_lowercase());
                content.push_str(&format!(
                    "- [{}](./{}) - {}\n",
                    page.title, filename, page.description
                ));
            }
            content.push('\n');
        }

        if !high_pages.is_empty() {
            content.push_str("## ğŸ“š Important Documentation\n\n");
            for page in high_pages {
                let filename = format!("{}.md", page.id.replace(' ', "-").to_lowercase());
                content.push_str(&format!(
                    "- [{}](./{}) - {}\n",
                    page.title, filename, page.description
                ));
            }
            content.push('\n');
        }

        if !medium_pages.is_empty() {
            content.push_str("## ğŸ“– Additional Resources\n\n");
            for page in medium_pages {
                let filename = format!("{}.md", page.id.replace(' ', "-").to_lowercase());
                content.push_str(&format!(
                    "- [{}](./{}) - {}\n",
                    page.title, filename, page.description
                ));
            }
            content.push('\n');
        }

        if !low_pages.is_empty() {
            content.push_str("## ğŸ“ Reference\n\n");
            for page in low_pages {
                let filename = format!("{}.md", page.id.replace(' ', "-").to_lowercase());
                content.push_str(&format!(
                    "- [{}](./{}) - {}\n",
                    page.title, filename, page.description
                ));
            }
        }
    }

    /// Generate navigation file
    fn generate_navigation_file(&self, wiki: &WikiStructure) -> String {
        let mut nav = String::new();
        nav.push_str("# ğŸ§­ Navigation\n\n");
        nav.push_str("Quick links to all documentation pages.\n\n");

        // Group by sections if available
        if !wiki.sections.is_empty() {
            for section in &wiki.sections {
                nav.push_str(&format!("## {}\n\n", section.title));
                for page_id in &section.pages {
                    if let Some(page) = wiki.pages.iter().find(|p| p.id == *page_id) {
                        let link = format!("{}.md", page.id.replace(' ', "-").to_lowercase());
                        let emoji = self.get_page_emoji(page);
                        nav.push_str(&format!(
                            "- {} [{}]({}) - {}\n",
                            emoji, page.title, link, page.description
                        ));
                    }
                }
                nav.push('\n');
            }
        } else {
            // Fallback to importance-based grouping
            self.add_pages_by_importance(&mut nav, wiki);
        }

        nav
    }

    /// Get emoji for page based on importance
    fn get_page_emoji(&self, page: &WikiPage) -> &'static str {
        if !self.options.use_emoji {
            return "";
        }

        match page.importance {
            ImportanceLevel::Critical => "ğŸ”¥",
            ImportanceLevel::High => "ğŸ“š",
            ImportanceLevel::Medium => "ğŸ“–",
            ImportanceLevel::Low => "ğŸ“",
        }
    }
}
