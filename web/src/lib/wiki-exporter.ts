/**
 * Wikiå¯¼å‡ºåŠŸèƒ½
 * å°†wikiå†…å®¹å¯¼å‡ºä¸ºmarkdownæ–‡ä»¶å¹¶æ‰“åŒ…æˆzip
 */

import JSZip from 'jszip';
import { WikiStructure, WikiPage, WikiSection } from '@/types/api';

/**
 * å¯¼å‡ºé…ç½®
 */
export interface ExportConfig {
  includeMetadata: boolean; // æ˜¯å¦åŒ…å«å…ƒæ•°æ®
  includeTableOfContents: boolean; // æ˜¯å¦ç”Ÿæˆç›®å½•
  fileNameFormat: 'title' | 'id'; // æ–‡ä»¶åæ ¼å¼
  folderStructure: 'flat' | 'hierarchical'; // æ–‡ä»¶å¤¹ç»“æ„
}

/**
 * é»˜è®¤å¯¼å‡ºé…ç½®
 */
const DEFAULT_EXPORT_CONFIG: ExportConfig = {
  includeMetadata: true,
  includeTableOfContents: true,
  fileNameFormat: 'title',
  folderStructure: 'hierarchical'
};

/**
 * å¯¼å‡ºç»Ÿè®¡ä¿¡æ¯
 */
export interface ExportStats {
  totalFiles: number;
  totalPages: number;
  totalSections: number;
  zipSize: number; // bytes
  exportTime: number; // ms
}

/**
 * Wikiå¯¼å‡ºå™¨ç±»
 */
export class WikiExporter {
  private config: ExportConfig;

  constructor(config: Partial<ExportConfig> = {}) {
    this.config = { ...DEFAULT_EXPORT_CONFIG, ...config };
  }

  /**
   * å¯¼å‡ºwikiä¸ºzipæ–‡ä»¶
   */
  public async exportToZip(wiki: WikiStructure): Promise<{ blob: Blob; stats: ExportStats }> {
    console.log('ğŸš€ Starting wiki export:', wiki.title);
    const startTime = performance.now();

    const zip = new JSZip();
    let fileCount = 0;

    // åˆ›å»ºæ ¹ç›®å½•
    const rootFolder = zip.folder(this.sanitizeFileName(wiki.title));
    if (!rootFolder) {
      throw new Error('Failed to create root folder');
    }

    // ç”ŸæˆREADME.md
    const readmeContent = this.generateReadme(wiki);
    rootFolder.file('README.md', readmeContent);
    fileCount++;

    // ç”Ÿæˆç›®å½•æ–‡ä»¶
    if (this.config.includeTableOfContents) {
      const tocContent = this.generateTableOfContents(wiki);
      rootFolder.file('TABLE_OF_CONTENTS.md', tocContent);
      fileCount++;
    }

    // å¯¼å‡ºé¡µé¢
    if (this.config.folderStructure === 'hierarchical') {
      // å±‚æ¬¡ç»“æ„å¯¼å‡º
      const pagesFolder = rootFolder.folder('pages');
      if (pagesFolder) {
        for (const page of wiki.pages) {
          fileCount += await this.exportPageHierarchical(pagesFolder, page);
        }
      }

      // å¯¼å‡ºæ ¹çº§ç« èŠ‚
      if (wiki.sections.length > 0) {
        const sectionsFolder = rootFolder.folder('sections');
        if (sectionsFolder) {
          for (const section of wiki.sections) {
            fileCount += await this.exportSectionHierarchical(sectionsFolder, section);
          }
        }
      }
    } else {
      // æ‰å¹³ç»“æ„å¯¼å‡º
      for (const page of wiki.pages) {
        fileCount += await this.exportPageFlat(rootFolder, page);
      }

      for (const section of wiki.sections) {
        fileCount += await this.exportSectionFlat(rootFolder, section, 'section');
      }
    }

    // ç”Ÿæˆzipæ–‡ä»¶
    const blob = await zip.generateAsync({
      type: 'blob',
      compression: 'DEFLATE',
      compressionOptions: { level: 6 }
    });

    const endTime = performance.now();

    const stats: ExportStats = {
      totalFiles: fileCount,
      totalPages: wiki.pages.length,
      totalSections: this.countSections(wiki.sections),
      zipSize: blob.size,
      exportTime: endTime - startTime
    };

    console.log('âœ… Wiki export completed:', stats);
    return { blob, stats };
  }

  /**
   * è§¦å‘ä¸‹è½½
   */
  public downloadZip(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * ç”ŸæˆREADME.md
   */
  private generateReadme(wiki: WikiStructure): string {
    const lines = [
      `# ${wiki.title}`,
      '',
      wiki.description,
      '',
      '## ğŸ“Š Statistics',
      '',
      `- **Pages**: ${wiki.pages.length}`,
      `- **Sections**: ${this.countSections(wiki.sections)}`,
      `- **Generated**: ${new Date().toISOString()}`,
      '',
      '## ğŸ“ Structure',
      '',
      '```',
      wiki.title + '/',
      'â”œâ”€â”€ README.md',
      'â”œâ”€â”€ TABLE_OF_CONTENTS.md',
      'â”œâ”€â”€ pages/',
      'â””â”€â”€ sections/',
      '```',
      '',
      '## ğŸ” How to Use',
      '',
      '1. Start with `TABLE_OF_CONTENTS.md` for an overview',
      '2. Browse pages in the `pages/` folder',
      '3. Explore sections in the `sections/` folder',
      '',
      '---',
      '',
      '*Generated by Wikify - https://github.com/your-repo/wikify*'
    ];

    return lines.join('\n');
  }

  /**
   * ç”Ÿæˆç›®å½•
   */
  private generateTableOfContents(wiki: WikiStructure): string {
    const lines = [
      `# Table of Contents - ${wiki.title}`,
      '',
      wiki.description,
      ''
    ];

    if (wiki.pages.length > 0) {
      lines.push('## ğŸ“„ Pages', '');
      wiki.pages.forEach((page, index) => {
        const importance = page.importance ? ` (${page.importance})` : '';
        lines.push(`${index + 1}. [${page.title}](pages/${this.getFileName(page.title, page.id)}.md)${importance}`);
        
        // æ·»åŠ é¡µé¢çš„ç« èŠ‚
        if (page.sections.length > 0) {
          page.sections.forEach(section => {
            lines.push(`   - [${section.title}](pages/${this.getFileName(page.title, page.id)}.md#${this.generateAnchor(section.title)})`);
            this.addSubsectionsToToc(lines, section.subsections, '     ');
          });
        }
      });
      lines.push('');
    }

    if (wiki.sections.length > 0) {
      lines.push('## ğŸ“‘ Sections', '');
      wiki.sections.forEach((section, index) => {
        lines.push(`${index + 1}. [${section.title}](sections/${this.getFileName(section.title, section.id)}.md)`);
        this.addSubsectionsToToc(lines, section.subsections, '   ');
      });
    }

    return lines.join('\n');
  }

  /**
   * é€’å½’æ·»åŠ å­ç« èŠ‚åˆ°ç›®å½•
   */
  private addSubsectionsToToc(lines: string[], subsections: WikiSection[], indent: string): void {
    subsections.forEach(subsection => {
      lines.push(`${indent}- [${subsection.title}](sections/${this.getFileName(subsection.title, subsection.id)}.md)`);
      if (subsection.subsections.length > 0) {
        this.addSubsectionsToToc(lines, subsection.subsections, indent + '  ');
      }
    });
  }

  /**
   * å±‚æ¬¡ç»“æ„å¯¼å‡ºé¡µé¢
   */
  private async exportPageHierarchical(folder: JSZip, page: WikiPage): Promise<number> {
    const content = this.generatePageMarkdown(page);
    const fileName = `${this.getFileName(page.title, page.id)}.md`;
    folder.file(fileName, content);

    let fileCount = 1;

    // å¦‚æœé¡µé¢æœ‰ç« èŠ‚ï¼Œåˆ›å»ºå­æ–‡ä»¶å¤¹
    if (page.sections.length > 0) {
      const pageFolder = folder.folder(this.sanitizeFileName(page.title));
      if (pageFolder) {
        for (const section of page.sections) {
          fileCount += await this.exportSectionHierarchical(pageFolder, section);
        }
      }
    }

    return fileCount;
  }

  /**
   * å±‚æ¬¡ç»“æ„å¯¼å‡ºç« èŠ‚
   */
  private async exportSectionHierarchical(folder: JSZip, section: WikiSection): Promise<number> {
    const content = this.generateSectionMarkdown(section);
    const fileName = `${this.getFileName(section.title, section.id)}.md`;
    folder.file(fileName, content);

    let fileCount = 1;

    // é€’å½’å¯¼å‡ºå­ç« èŠ‚
    if (section.subsections.length > 0) {
      const sectionFolder = folder.folder(this.sanitizeFileName(section.title));
      if (sectionFolder) {
        for (const subsection of section.subsections) {
          fileCount += await this.exportSectionHierarchical(sectionFolder, subsection);
        }
      }
    }

    return fileCount;
  }

  /**
   * æ‰å¹³ç»“æ„å¯¼å‡ºé¡µé¢
   */
  private async exportPageFlat(folder: JSZip, page: WikiPage): Promise<number> {
    const content = this.generatePageMarkdown(page);
    const fileName = `page_${this.getFileName(page.title, page.id)}.md`;
    folder.file(fileName, content);

    let fileCount = 1;

    // å¯¼å‡ºé¡µé¢çš„ç« èŠ‚
    for (const section of page.sections) {
      fileCount += await this.exportSectionFlat(folder, section, 'page_section');
    }

    return fileCount;
  }

  /**
   * æ‰å¹³ç»“æ„å¯¼å‡ºç« èŠ‚
   */
  private async exportSectionFlat(folder: JSZip, section: WikiSection, prefix: string): Promise<number> {
    const content = this.generateSectionMarkdown(section);
    const fileName = `${prefix}_${this.getFileName(section.title, section.id)}.md`;
    folder.file(fileName, content);

    let fileCount = 1;

    // é€’å½’å¯¼å‡ºå­ç« èŠ‚
    for (const subsection of section.subsections) {
      fileCount += await this.exportSectionFlat(folder, subsection, `${prefix}_subsection`);
    }

    return fileCount;
  }

  /**
   * ç”Ÿæˆé¡µé¢markdownå†…å®¹
   */
  private generatePageMarkdown(page: WikiPage): string {
    const lines = [`# ${page.title}`, ''];

    // æ·»åŠ å…ƒæ•°æ®
    if (this.config.includeMetadata) {
      lines.push('---');
      lines.push(`id: ${page.id}`);
      lines.push(`importance: ${page.importance}`);
      if (page.file_paths.length > 0) {
        lines.push(`files:`);
        page.file_paths.forEach(path => lines.push(`  - ${path}`));
      }
      if (page.related_pages.length > 0) {
        lines.push(`related_pages:`);
        page.related_pages.forEach(id => lines.push(`  - ${id}`));
      }
      lines.push('---', '');
    }

    // æ·»åŠ å†…å®¹
    lines.push(page.content);

    // æ·»åŠ ç« èŠ‚
    if (page.sections.length > 0) {
      lines.push('', '## Sections', '');
      page.sections.forEach(section => {
        lines.push(`- [${section.title}](#${this.generateAnchor(section.title)})`);
      });

      page.sections.forEach(section => {
        lines.push('', `## ${section.title}`, '');
        lines.push(section.content);
        this.addSubsectionsToMarkdown(lines, section.subsections, 3);
      });
    }

    return lines.join('\n');
  }

  /**
   * ç”Ÿæˆç« èŠ‚markdownå†…å®¹
   */
  private generateSectionMarkdown(section: WikiSection): string {
    const lines = [`# ${section.title}`, ''];

    // æ·»åŠ å…ƒæ•°æ®
    if (this.config.includeMetadata) {
      lines.push('---');
      lines.push(`id: ${section.id}`);
      lines.push('---', '');
    }

    // æ·»åŠ å†…å®¹
    lines.push(section.content);

    // æ·»åŠ å­ç« èŠ‚
    this.addSubsectionsToMarkdown(lines, section.subsections, 2);

    return lines.join('\n');
  }

  /**
   * é€’å½’æ·»åŠ å­ç« èŠ‚åˆ°markdown
   */
  private addSubsectionsToMarkdown(lines: string[], subsections: WikiSection[], level: number): void {
    subsections.forEach(subsection => {
      const heading = '#'.repeat(level);
      lines.push('', `${heading} ${subsection.title}`, '');
      lines.push(subsection.content);
      
      if (subsection.subsections.length > 0) {
        this.addSubsectionsToMarkdown(lines, subsection.subsections, level + 1);
      }
    });
  }

  /**
   * è·å–æ–‡ä»¶å
   */
  private getFileName(title: string, id: string): string {
    if (this.config.fileNameFormat === 'id') {
      return this.sanitizeFileName(id);
    }
    return this.sanitizeFileName(title);
  }

  /**
   * æ¸…ç†æ–‡ä»¶å
   */
  private sanitizeFileName(name: string): string {
    return name
      .replace(/[<>:"/\\|?*]/g, '_') // æ›¿æ¢éæ³•å­—ç¬¦
      .replace(/\s+/g, '_') // æ›¿æ¢ç©ºæ ¼
      .replace(/_+/g, '_') // åˆå¹¶å¤šä¸ªä¸‹åˆ’çº¿
      .replace(/^_|_$/g, '') // ç§»é™¤é¦–å°¾ä¸‹åˆ’çº¿
      .toLowerCase();
  }

  /**
   * ç”Ÿæˆé”šç‚¹
   */
  private generateAnchor(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-');
  }

  /**
   * ç»Ÿè®¡ç« èŠ‚æ•°é‡
   */
  private countSections(sections: WikiSection[]): number {
    let count = sections.length;
    sections.forEach(section => {
      count += this.countSections(section.subsections);
    });
    return count;
  }
}

/**
 * å…¨å±€å¯¼å‡ºå™¨å®ä¾‹
 */
export const wikiExporter = new WikiExporter();
